"""
This code runs a particle swarm optimization scheme on GOSIA to try to find the best 
minimum. PSO is random and not reproducible. For best results, run multiple instances of this
code and take the best result, then put it into a traditional fitter for fine-tuning. This
code requires GOSIA input files for OP,INTI, OP,MAP, and OP,POIN (for beam and target), with 
several specific modifications to them. The code will draw the boundary conditions from the 
OP,INTI input files (from the bounds you set in OP,EXPT). PSO relies on good selection of
boundary conditions for best results, so try to make them tight where possible (for example,
well known target matrix elements should be constrained to within a few sigma of the
literature value). In the OP,POIN input, comments are needed on the following lines in 
OP,YIEL:

YNRM - please comment this line with !YNRM
UPL - please comment this line with !UPL
NBRA - please comment this line with !BR
NL - please comment this line with !LT
NDL - please comment this line with !DL
NAMX - please comment this line with !ME

These comments are used for functions that parse the input file to be able to find your limits
and constraints. Note that this code is not set up to handle multiple YNRM or UPL values, so 
you will need to select one instance to comment and that's what the code will use.

You will also need to generate format your yields file in a very specific way. Every 
transition that will be generated by OP,POIN needs to be included, and for unobserved
transitions record the counts and uncertainty as 0 for both. The transitions also need to be
listed in the same order as they appear in OP,POIN (if you're not sure what that is, just 
run OP,POIN and check the order and then format them to match that). The parser assumes that
user-generated files, including this one, use comma separated values, not space separated.
Files that GOSIA generates it assumes the default format in which those files are generated.

There are also two changes to the code that need to be made for each user. In 
fileManagement.py, in the first line of the createSubDirectories function, you will need to 
specify the path to where the subdirectories should be created. The use of subdirectories is
so we can run multiple threads simultaneously. The other change is in myconfig.py. You will 
need to modify this file to include the names of your input files. These should not be 
absolute paths, just the file names. The path will be determined by the directory the code is
run in.

Before running this code, I recommend that you get a 'reasonable' fit from GOSIA or another
minimizer. This is so the corrected yields are relatively correct. Alternatively, you can
start with a terrible fit and use this code to iterively find better 'starting' positions
for the integration, but this takes a long time to run and it will likely be much faster to
just get a quick fit from GOSIA first.

After that, you SHOULD be able to run without any additional modifications. It's possible that
some GOSIA input files will not be read correctly by the parser if they use very different
options than I did. If that's the case, you may need to modify the code in parseGosiaInputs.py
to get it to read your input file properly.
"""
import numpy as np
import pyswarms.backend as P
import parseGosiaInputs
import runGosia
from pyswarms.backend.topology import Ring
from pyswarms.backend.topology import Star
from pyswarms.backend.handlers import VelocityHandler
from pyswarms.backend.handlers import BoundaryHandler
from myconfig import *
import threading
import fileManagement
import os
import sys

#Takes an integer as an argument. Only effects where the name of the output file and the temp 
#directories for running GOSIA by default. Useful for running many instances in parallel.
#Ensure a different batch number is used for each instance when running simultaneously.
batchNumber = int(sys.argv[1])

#Initializes the process of computing the particle chisq values, including dividing up the 
#particles between multiple threads.
def getSwarmChisq(positions,iteration,nThreads=1):
  particlesPerThread = int(np.ceil(len(positions)/nThreads))
  threadFirstLast = []
  folderStart = batchNumber*nThreads
  for j in range(nThreads):
    chainDirPrefix = fileManagement.createSubDirectories(folderStart + j)
    threadFirstLast.append((particlesPerThread*j,min(particlesPerThread*(j+1),len(positions))))
  
  chisqDict = {}
  tmpChisqArray = []
  for j in range(nThreads):
    chainDir = chainDirPrefix + str(folderStart + j)
    tmpChisqArray.append(threading.Thread(target=getParticleChisq, args=[positions,iteration,threadFirstLast[j],chainDir,chisqDict], name='t%i' % j))
    tmpChisqArray[j].start()

  for j in range(nThreads):
    tmpChisqArray[j].join()
  
  chisqArray = []
  for firstLast in threadFirstLast:
    chisqArray += chisqDict[firstLast[0]]
  chisqArray = np.array(chisqArray)
  return chisqArray
  
#Each thread calls this function once. Loops over all particles assigned to that thread and
#computes the chisq values.
def getParticleChisq(positions,iteration,threadFirstLast,chainDir,chisqDict):
  chisqArray = []
  for i in range(threadFirstLast[0],threadFirstLast[1]):
    parseGosiaInputs.make_bst(os.path.join(chainDir,beam_bst),positions[i][:nBeamParams])
    parseGosiaInputs.make_bst(os.path.join(chainDir,target_bst),positions[i][nBeamParams:])
    runGosia.runGosiaInDir(beamMINIinp,chainDir)
    runGosia.runGosiaInDir(targetMINIinp,chainDir)
    beamOutputFile = os.path.join(chainDir,parseGosiaInputs.getOutputFile(beamMINIinp))
    targetOutputFile = os.path.join(chainDir,parseGosiaInputs.getOutputFile(targetMINIinp))
    beamINTIout = os.path.join(chainDir,parseGosiaInputs.getOutputFile(beamINTIinp))
    targetINTIout = os.path.join(chainDir,parseGosiaInputs.getOutputFile(targetINTIinp))
    beamCorrFile = os.path.join(chainDir,parseGosiaInputs.getCorrFile(beamMINIinp))
    targetCorrFile = os.path.join(chainDir,parseGosiaInputs.getCorrFile(targetMINIinp))
    computedObservables = parseGosiaInputs.getPOINobservables(beamOutputFile)
    computedObservables += parseGosiaInputs.getPOINobservables(targetOutputFile)
    expt = []
    scalingFactors = []
    for j in range(len(beamExptMap)):
      expt.append(beamExptMap[j][0])
    for j in range(len(targetExptMap)):
      expt.append(targetExptMap[j][0])
    nExpt = max(expt)
    for j in range(nExpt):
      tempSum1 = 0
      tempSum2 = 0
      for k in range(len(expt)):
        if expt[k] == j+1 and observables[k] != 0:
          tempSum1 += (observables[k]*computedObservables[k])/uncertainties[k]**2
          tempSum2 += computedObservables[k]**2/uncertainties[k]**2
      scalingFactor = tempSum1/tempSum2
      scalingFactors.append(scalingFactor)
    for j in range(nExpt):
      for k in range(len(expt)):
        if expt[k] == j+1:
          computedObservables[k] *= scalingFactors[j]
    nObservables = len(observables)
    chisq = 0
    for j in range(nObservables):
      if observables[j] != 0:
        chisq += ((computedObservables[j]-observables[j])/uncertainties[j])**2
      elif expt[j] != 0:
        if j < len(beamExptMap) and computedObservables[j] >= exptUpperLimits[expt[j]-1][0]:
          chisq += ((computedObservables[j]-exptUpperLimits[expt[j]-1][0])/exptUpperLimits[expt[j]-1][0])**2
        elif j >= len(beamExptMap) and computedObservables[j] >= exptUpperLimits[expt[j]-1][1]:
          chisq += ((computedObservables[j]-exptUpperLimits[expt[j]-1][1])/exptUpperLimits[expt[j]-1][1])**2
    chisqArray.append(chisq)
  chisqDict[threadFirstLast[0]] = chisqArray
  return 

#Initializes everything
nThreads = 20 #number of threads used for particles
#nBeamParams = 17 #number of matrix elements for the sn112 beam
#nBeamParams = 13 #sn116, sn120
nBeamParams = 19 #ge80
#nDimensions = 41 #total number of parameters for sn112
#nDimensions = 36 #sn120
#nDimensions = 37 #sn116
nDimensions = 44 #ge80
nParticles = 600
cognitiveCoeff = 1.75
socialCoeff = 1.0
inertialCoeff = 0.7

#Gets the bounds for each matrix element from the INTI files.
beamMatrixElements = parseGosiaInputs.getMatrixElements(beamINTIinp)
targetMatrixElements = parseGosiaInputs.getMatrixElements(targetINTIinp)
beamLoBounds = beamMatrixElements["LoBound"].to_numpy()
beamHiBounds = beamMatrixElements["HiBound"].to_numpy()
targetLoBounds = targetMatrixElements["LoBound"].to_numpy()
targetHiBounds = targetMatrixElements["HiBound"].to_numpy()
loBounds = np.concatenate((beamLoBounds,targetLoBounds))
hiBounds = np.concatenate((beamHiBounds,targetHiBounds))
paramBounds = (loBounds,hiBounds)

#Run GOSIA to initialize everything. This is the only time INTI will be run, so use a
#reasonable initial guess. If you don't have one, you can always run with a bad one and 
#use this program to try to get a better initial guess. 
#runGosia.runGosia2(beamINTIinp)
#runGosia.runGosia2(targetINTIinp)
#runGosia.runGosia(beamMAPinp)
#runGosia.runGosia(targetMAPinp)
beamCorr = parseGosiaInputs.getCorrFile(beamINTIinp)
targetCorr = parseGosiaInputs.getCorrFile(targetINTIinp)

#Get experimental observables and the beam and target maps
observables,uncertainties,beamExptMap,targetExptMap = parseGosiaInputs.getExperimentalObservables(beamYields,targetYields,beamCorr,targetCorr,beamMINIinp,targetMINIinp)
exptUpperLimits = parseGosiaInputs.getUpperLimits(beamMINIinp,targetMINIinp,beamExptMap,targetExptMap,observables)

#Initialize the particle swarm
#Papers I read suggested that VonNeumann is typically the best topology. With this many 
#dimensions, Star is equivalent to VonNeumann. I found the best approach was to start with a
#local topology (Ring) and increase the number of neighbors every 50 iterations until
#eventually progressing to the Star topology. This allows the particles to first explore the
#space near where they start and prevents premature convergence to a local minimum.
my_topology = Ring(static=False) 
#Next line only needed if running Ring topology
velocityHandler = VelocityHandler(strategy='invert')
#BoundaryHandler
boundaryHandler = BoundaryHandler(strategy='reflective')
#boundaryHandler = BoundaryHandler(strategy='intermediate')
#boundaryHandler = BoundaryHandler(strategy='random')
#boundaryHandler = BoundaryHandler(strategy='shrink')

#c1 is the cognitive parameter (velocity component towards particle's own best position)
#c2 is the social parameter (velocity component towards best position of particle it can see)
#c2 pulls towards global minimum in star topology since the graph is fully connected
#w is the inertial parameter (velocity component in direction of last iteration's velocity)
my_options = {'c1' : cognitiveCoeff, 'c2' : socialCoeff, 'w' : inertialCoeff}
my_swarm = P.create_swarm(n_particles=nParticles,dimensions=nDimensions,bounds=paramBounds,options=my_options)

iterSwitch = 350
neighborsArray = [20,30,40,60,80,120,160]

#bestParams = parseGosiaInputs.read_bst(beam_bst)
#bestParams += parseGosiaInputs.read_bst(target_bst)
#my_swarm.position[0,:] = bestParams
iterations = 500
for i in range(iterations):
  if i == iterSwitch:
    my_topology = Star()
  
  #Get the chisq for each particle position
  my_swarm.current_cost = getSwarmChisq(my_swarm.position,i,nThreads)
  #initial best cost and best position for each particle 
  if i == 0:
    my_swarm.pbest_cost = my_swarm.current_cost
    my_swarm.pbest_pos = my_swarm.position
  #If it's not the first iteration, check if this position is better than particle's best
  #and update if it is.
  else:
    for j in range(len(my_swarm.current_cost)):
      if my_swarm.current_cost[j] <= my_swarm.pbest_cost[j]:
        my_swarm.pbest_pos[j] = my_swarm.position[j]
        my_swarm.pbest_cost[j] = my_swarm.current_cost[j]
  
  #Track the global best cost
  if np.min(my_swarm.pbest_cost) < my_swarm.best_cost:
    if i < iterSwitch:
      my_swarm.best_pos, my_swarm.best_cost = my_topology.compute_gbest(my_swarm,2,neighborsArray[int(np.floor(i/50))])
      best_iter = i
    else:
      my_swarm.best_pos, my_swarm.best_cost = my_topology.compute_gbest(my_swarm)
      best_iter = i

  #If we haven't gotten better in 50 iterations, we probably are stuck in a local minimum
  #if i > best_iter + 50:
    #break

  print('Iteration: {} | my_swarm.best_cost: {:.4f}'.format(i+1, my_swarm.best_cost))

  
  #Update velocities and positions for the next iteration
  if i < iterSwitch:
    my_swarm.velocity = my_topology.compute_velocity(my_swarm,clamp=None,vh=velocityHandler,bounds=(loBounds,hiBounds))
    my_swarm.position = my_topology.compute_position(my_swarm,bounds=paramBounds,bh=boundaryHandler)
  else:
    my_swarm.velocity = my_topology.compute_velocity(my_swarm)
    my_swarm.position = my_topology.compute_position(my_swarm,bounds=paramBounds,bh=boundaryHandler)

f = open('adaptiveParticleSwarmResult_%i.csv' % batchNumber,'w')
f.write('The best cost found by our swarm is: {:.4f}\n'.format(my_swarm.best_cost))
f.write('The best position found by our swarm is: {}\n'.format(my_swarm.best_pos))
f.write('The number of iterations needed was: {}'.format(i))
f.close()